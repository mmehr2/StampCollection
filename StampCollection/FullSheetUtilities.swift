//
//  FullSheetUtilities.swift
//  StampCollection
//
//  Created by Michael L Mehr on 7/20/17.
//  Copyright Â© 2017 Michael L. Mehr. All rights reserved.
//

import Foundation

/*
 The two tasks here (U7, U8) involve creating CSV listings for full sheets using derived data from BTItemDetails and sets (cat 2)
 The first task (U7) deals with correcting entries for existing inventory.
 The second task (U8) deals with creating new entries as web data additions are detected.
 Theoretically, U7 should only need to be run once. However, if BT changes the basic set descriptions or data, we may need to rerun it.
 U8 should be run every time updates with new set items are detected.
 Currently, all output goes to the debug console for capture and inclusion in INFO.CSV and subsequent import.
 TBD - eventually this needs to be automated and triggered by the Updates process incrementally (4-5x / yr as IPS releases occur).
 
 I have manually entered detailed sheet info (including denominations) for the 1948+ series. 
 Also the first few of 1960+ (provisionals, airmail, a couple more).
 The info for the rest was auto-generated by the PHP code, but only says "Full Sheet" in the description suffix.
 The starting set needing update is from 6110s96 (1960 12th Independence).
 This was for sets up to 6110s1213 (2013 Hashomer Hatzair). After that, no entries were generated at all.
 Therefore we need U7 to do fixups or regens of everything after s95
 
 Set cardinality - how many sheets are in the published set
 This is typically determined from BTItemDetails plateNumbers list.
 Certain sets (Anemone, SongBirds, Shekel Stand-by) have no plate numbers (p--) so a table of exceptions is needed.
 Also certain other sets (Doar Ivri, '49 Flag, others) reused the same plate number multiple times
 This is probably best implemented in the BTItemDetails class itself by a static ID-code table.
 NOTE: Cat1 or cat2 fields could also be used, but don't exist after certain dates (currently, mid-2013). This no doubt requires labor by the BT site team whenever a new Carmel catalog is released.
 Exceptiopns: BT lists plate numbers inaccurately in these cases (need a table)
    6110sXXX 1969 Town Emblems II - p250-262 counts 13/12 (however 259 was never issued - I have a blank album page there)
 
 Further notes on cat1, cat2:
 This needs to be done in BTDealerItem. It is similar to the plate number list parsing, but complicated by several things:
   1. Alphanumeric prefix/suffix conventions: consider C numbers like B88 or 431,432 or 1893-96, or S numbers 1708a-c or J6-J11
   2. Errors (see fixCatField() in BTDealerItem.swift)
   3. Anomalies such as 6110s323 "1978 Memorial Day": "C ---" and "S 694a-" (could poss.be fixed by new rule tho)
 
 An ideal example: 6110s352,"1980 Thistles"
 The original PHP code created (old way):
 6110t352_01,"1980 Thistles- Full sheet",Unavailable,6110s352,0,"(X)Full Sheets","C 867full","S 745full",10.00,0.00,,,0,0,0,0,,,,,31
 6110t352_02,"1980 Thistles- Full sheet",Unavailable,6110s352,0,"(X)Full Sheets","C 868full","S 746full",10.00,0.00,,,0,0,0,0,,,,,31
 6110t352_03,"1980 Thistles- Full sheet",Unavailable,6110s352,0,"(X)Full Sheets","C 869full","S 747full",10.00,0.00,,,0,0,0,0,,,,,31
 from:
 6110s352,"1980 Thistles","In Stock",6110s352,0,"Sets, SS, FDC","C 867-869","S 745-747",0.73,0.98,0.73,0.63,1,1,1,1,,,,,2
 This code should at minimum be able to add the BTItemDetails sheet info so it looks like this:
 6110t352_01,"1980 Thistles- Full sheet (#1/3) [Pl.No.587(1960+) Format=(3x5)] Designer A.Glaser",Catalog,6110s352,0,"(X)Full Sheets","C 867full","S 745full",10.00,0.00,,,0,0,0,0,,,,,31
 6110t352_02,"1980 Thistles- Full sheet (#2/3) [Pl.No.588(1960+) Format=(3x5)] Designer A.Glaser",Catalog,6110s352,0,"(X)Full Sheets","C 868full","S 746full",10.00,0.00,,,0,0,0,0,,,,,31
 6110t352_03,"1980 Thistles- Full sheet (#3/3) [Pl.No.589(1960+) Format=(3x5)] Designer A.Glaser",Catalog,6110s352,0,"(X)Full Sheets","C 869full","S 747full",10.00,0.00,,,0,0,0,0,,,,,31


 The tasks involved:
 Modify (or create) a family of 6110t full sheet entries for each 6110s set which is not a Souvenir Sheet:
    For set cardinality N, create N entries modifying the fields from the original
        id: change 's' to 't' and add suffix "_nn" where nn goes from '01' to '0N' or 'NN' (if N>=10)
        pictid: set equal to 6110s id
        group: set to "(X)Full Sheets"
        cat1,cat2: After every individual cat item, add the word "full" (my convention)
 */

let CATEG_SHEETS:Int16 = 31
class U7Task: NSObject, UtilityTaskRunnable {
    
    var task: UtilityTask! {
        didSet {
            // set up the proxy once we know the object's reference
            task.reportedTaskUnits = TU
            task.isEnabled = isEnabled
            task.taskName = taskName
            // protocol: set initial taskUnits to non-0 if we have work, 0 if we don't (database category empty)
            task.taskUnits = task.countCategories([CATEG_SHEETS])
        }
    }
    
    let TU:Int64 = 35000 // generate this as approx msec execution time on my device; only relative size matters
    // protocol: UtilityTaskRunnable
    var isEnabled = false
    var taskName: String { return "UT2017_08_14_MODIFY_EXISTING_FULL_SHEETS" }
    
    private weak var runner: UtilityTaskRunner! // prevent circular refs, we're in each other's tables
        // MARK: Task data and functions
    func run() -> String {
        var result = ""
        var firstCode = ""
        var lastCode = ""
        var firstDesc = ""
        var lastDesc = ""
        var totalAdded = 0
        let objects1 = task.model.fetchInfoInCategory(CATEG_SETS, withSearching: [], andSorting: .none, fromContext: task.contextToken)
        guard objects1.count > 0 else {
            print("Empty database - don't run task \(taskName) yet.")
            return result
        }
        let store = BTDealerStore.model
        let cats = store.categories
        let category = Int(CATEG_SETS) // numbered from 1
        guard cats.count > category else {
            print("No category \(category) object to process.")
            return result
        }
        let objects = cats[category-1].getAllDataItems()
        if objects.count > 0 {
            let totalSteps = Int64(objects.count)
            task.taskUnits = totalSteps
            var stepCount:Int64 = 0
            for item in objects {
                if let details = item.details {
                    if !details.isSouvenirSheet {
                        // for every non-S/S set in the BT inventory, create a set of sheet listings
                        let (_, cnumStr) = splitNumericEndOfString(item.code)
                        let cnum = Int(cnumStr)!
                        let codeFormat1 = "6110t\(cnum),"
                        let codeFormatN = "6110t\(cnum)_%02d,"
                        let descPrefix = "\"\(item.descr)- "
                        let descSuffix = "\",Catalog,\(item.code),0,\"(X)Full Sheets\","
                        let cat1Suffix = ","
                        let cat2Suffix = ",10.00,,20.00,,0,0,0,0,,,,,31"
                        let descList = details.fullSheetDetails
                        let cat1List = item.catalog1List
                        let cat2List = item.catalog2List
                        let cardinality = descList.count
                        let codeFormat = (cardinality == 1 ? codeFormat1 : codeFormatN)
                        // create the properly formatted colums of data
                        let numList = Array(1...cardinality).map{ String(format: codeFormat, $0) }
                        let descs = descList.map{ descPrefix + $0 + descSuffix }
                        let cat1s = cat1List.map{ ($0.isEmpty ? "" : "\"\($0)\"" ) + cat1Suffix }
                        let cat2s = cat2List.map{ ($0.isEmpty ? "" : "\"\($0)\"" ) + cat2Suffix }
                        // perform a 4-way zip of these formatted columns
                        let fs1 = zip(numList, descs).flatMap{ x, y in return x+y }
                        let fs2 = zip(fs1, cat1s).flatMap{ x, y in return x+y }
                        let fs3 = zip(fs2, cat2s).flatMap{ x, y in return x+y }
                        let sheetList = fs3.joined(separator: "\n")
                        print("\(sheetList)")
                        
                        if firstCode.isEmpty {
                            firstCode = item.code
                        }
                        lastCode = item.code
                        if firstDesc.isEmpty {
                            firstDesc = item.descr
                        }
                        lastDesc = item.descr
                        totalAdded += 1
                    }
                }
                stepCount += 1
                task.updateTask(step: stepCount, of: totalSteps)
            }
        }
        if totalAdded > 0 {
            result = "Created \(totalAdded) CSV entries for full sheets for sets from \(firstCode): \(firstDesc) to \(lastCode): \(lastDesc)."
            print(result)
        }
        return result
    }
}

class U8Task: NSObject, UtilityTaskRunnable {
    
    var task: UtilityTask! {
        didSet {
            // set up the proxy once we know the object's reference
            task.reportedTaskUnits = TU
            task.isEnabled = isEnabled
            task.taskName = taskName
            // protocol: set initial taskUnits to non-0 if we have work, 0 if we don't (database category empty)
            // NOTE: this will be way off, so a better estimate method should be designed
            // The real amount of work is the difference between the number of sheets in the data model and the number of
            //   sheets that can come from the BT store items in the set category.
            // A method can be devised to add up set cardinality numbers from the BT store category items.
            task.taskUnits = task.countCategories([CATEG_SHEETS])
        }
    }
    
    let TU:Int64 = 35000 // generate this as approx msec execution time on my device; only relative size matters
    // protocol: UtilityTaskRunnable
    var isEnabled = false
    var taskName: String { return "UT2017_07_20_ADD_MISSING_FULL_SHEETS" }
    
    private weak var runner: UtilityTaskRunner! // prevent circular refs, we're in each other's tables
    
    // MARK: Task data and functions
    func run() -> String {
        return ""
    }
}
