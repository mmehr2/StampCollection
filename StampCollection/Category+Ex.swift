//
//  Category+Ex.swift
//  StampCollection
//
//  Created by Michael L Mehr on 5/6/15.
//  Copyright (c) 2015 Michael L. Mehr. All rights reserved.
//

import Foundation
import CoreData

/*
This class provides useful extensions to the CoreData object model classes, to allow them to remain re-generateable by XCode 6.3.
Currently it seems that these generated classes are all @NSManaged properties, and any additions will be clobbered.
*/

let CATNUM_AUSTRIAN = Int16(28)
private let CATNUM_INFOLDER = Int16(29)
private let CATNUM_BULLETIN = Int16(30)
private let CATNUM_SHEETS = Int16(31)
private let CATNUM_JOINT = Int16(13)
//private let CATNUM_ = Int16(0)

private let nonupdateables = [
    CATNUM_INFOLDER,
    CATNUM_BULLETIN,
    CATNUM_SHEETS,
]

extension Category {
    
    enum ValueType {
        case tInt(NSNumber)
        case tString(String)
    }
    
    var updateable : Bool {
        return !nonupdateables.contains(number)
    }
    
    fileprivate static func translateKeyName( _ nameIn: String, forExport: Bool = false ) -> String {
        var name = nameIn
        // translate key name if needed (not allowed to use 1st letter as capital, not allowed to use the word "description"
        switch name {
        case "#": name = "number"
        case "number": name = "#"
        default:
            // need to lowercase/uppercase the 1st character in the name
            let index = name.characters.index(after: name.startIndex)
            let firstChar = forExport ? name.substringToIndex(index).uppercased() : name.substringToIndex(index).lowercased()
            let rest = name.substring(from: index)
            name = firstChar + rest
        }
        return name
    }
    
    fileprivate static func typeForKeyName( _ name: String, withValue value: String ) -> ValueType {
        var output = ValueType.tString(value)
        // translate key name if needed (not allowed to use 1st letter as capital, not allowed to use the word "description"
        switch name {
        case "number": output = ValueType.tInt(NSNumber(value: Int(value)! as Int))
        case "exOrder": output = ValueType.tInt(NSNumber(value: Int(value)! as Int)) // autosequencing property generated by import processor
        default: break
        }
        return output
    }
    
    fileprivate static func setDataValuesForObject( _ newObject: Category, fromData  data: [String : String]) {
        for (key, value) in data {
            // translate key name if needed (not allowed to use 1st letter as capital, not allowed to use the word "description"
            let keyName = translateKeyName(key)
            // set the attributes of the new object (allows Int16 type or String type, for now)
            let valueType = typeForKeyName( keyName, withValue: value )
            switch valueType {
            case .tInt (let val): newObject.setValue(val, forKey: keyName)
            case .tString: newObject.setValue(value, forKey: keyName)
            }
        }
    }
    
    static func makeObjectFromData( _ data: [String : String], inContext moc: NSManagedObjectContext? = nil) -> Bool {
        // add a new object of this type to the moc
        if let moc = moc {
            let entityName = "Category"
            if let newObject = NSEntityDescription.insertNewObject(forEntityName: entityName, into: moc) as? Category {
                Category.setDataValuesForObject(newObject, fromData: data)
                return true
            } else {
                // report error creating object in CoreData MOC
                print("Unable to make CoreData Category from data \(data)")
            }
        }
        return false
    }

    // return the names of the data properties, in import/export order (from the CSV file)
    static func getDataHeaderNames() -> [String] {
        var output : [String] = []
        //In Defined Order for CSV file:
        // Code,#,Name,Items,Catalogs,Prices
        output.append("code")
        output.append("number")
        output.append("name")
        output.append("items")
        output.append("catalogs")
        output.append("prices")
        return output
    }
    
    static func getExportHeaderNames() -> [String] {
        var output : [String] = []
        //In Defined Order for CSV file:
        // Code,#,Name,Items,Catalogs,Prices
        output = getDataHeaderNames().map { x in
            self.translateKeyName(x, forExport: true)
        }
        return output
    }
    
    func makeDataFromObject() -> [String : String] {
        var output: [String : String] = [:]
        let headerNames = Category.getDataHeaderNames()
        //println("Category header names are \(headerNames)")
        for headerName in headerNames {
            let keyname = Category.translateKeyName(headerName, forExport: true)
            switch headerName {
            case "name", "code", "items", "catalogs", "prices":
                let value = self.value(forKey: headerName) as? String ?? ""
                output[keyname] = value
                break
            case "number":
                let value = self.value(forKey: headerName) as? Int ?? 0
                output[keyname] = "\(value)"
                break
            default: break // ignore any auto-generated properties; we just want the basics
            }
        }
        //println("New Category data is \(output)")
        return output
    }
    
}
